/**
 * FDF 导出器
 * 
 * 将 FrameData 转换为 FDF 格式文本
 */

import { FrameData } from '../types';

/**
 * 导出选项
 */
export interface ExportOptions {
  /** 缩进字符串 */
  indent?: string;
  /** 是否包含注释 */
  includeComments?: boolean;
  /** 基础画布宽度（用于转换相对坐标） */
  baseWidth?: number;
  /** 基础画布高度（用于转换相对坐标） */
  baseHeight?: number;
}

/**
 * FDF 导出器
 */
export class FDFExporter {
  private options: Required<ExportOptions>;
  private indentLevel: number = 0;
  
  constructor(options: ExportOptions = {}) {
    this.options = {
      indent: options.indent ?? '\t',
      includeComments: options.includeComments ?? true,
      baseWidth: options.baseWidth ?? 800,
      baseHeight: options.baseHeight ?? 600,
    };
  }
  
  /**
   * 导出 Frame 数组为 FDF 文本
   */
  public export(frames: FrameData[]): string {
    let fdf = '';
    
    if (this.options.includeComments) {
      fdf += '// Generated by WC3 UI Designer\n';
      fdf += `// ${new Date().toISOString()}\n`;
      fdf += '\n';
    }
    
    for (const frame of frames) {
      fdf += this.exportFrame(frame);
      fdf += '\n';
    }
    
    return fdf;
  }
  
  /**
   * 导出单个 Frame
   */
  private exportFrame(frame: FrameData): string {
    let fdf = '';
    
    const frameType = this.mapFrameType(frame.type);
    const frameName = frame.name || `Frame_${frame.id}`;
    
    // Frame 定义
    fdf += this.getIndent() + `Frame "${frameType}" "${frameName}" {\n`;
    this.indentLevel++;
    
    // 尺寸
    if (frame.width) {
      fdf += this.getIndent() + `Width ${this.toRelative(frame.width, this.options.baseWidth)}\n`;
    }
    if (frame.height) {
      fdf += this.getIndent() + `Height ${this.toRelative(frame.height, this.options.baseHeight)}\n`;
    }
    
    // 锚点
    if (frame.anchors && frame.anchors.length > 0) {
      for (const anchor of frame.anchors) {
        const pointName = this.mapFramePointToName(anchor.point);
        
        if (anchor.relativeTo) {
          // SetPoint 相对定位
          const relativePointName = this.mapFramePointToName(anchor.relativePoint || 0);
          const offsetX = this.toRelative(anchor.x, this.options.baseWidth);
          const offsetY = this.toRelative(anchor.y, this.options.baseHeight);
          fdf += this.getIndent() + `SetPoint ${pointName}, "${anchor.relativeTo}", ${relativePointName}, ${offsetX}, ${offsetY}\n`;
        } else {
          // Anchor 绝对定位
          const x = this.toRelative(anchor.x, this.options.baseWidth);
          const y = this.toRelative(anchor.y, this.options.baseHeight);
          fdf += this.getIndent() + `Anchor ${pointName}, ${x}, ${y}\n`;
        }
      }
    }
    
    // 文本
    if (frame.text) {
      fdf += this.getIndent() + `Text "${this.escapeString(frame.text)}"\n`;
    }
    
    if (frame.textColor) {
      const rgba = this.hexToRgba(frame.textColor);
      fdf += this.getIndent() + `FontColor ${rgba.r} ${rgba.g} ${rgba.b} ${rgba.a}\n`;
    }
    
    if (frame.horAlign) {
      const justification = this.mapHorizontalAlign(frame.horAlign);
      fdf += this.getIndent() + `FontJustificationH ${justification}\n`;
    }
    
    if (frame.verAlign) {
      const justification = this.mapVerticalAlign(frame.verAlign);
      fdf += this.getIndent() + `FontJustificationV ${justification}\n`;
    }
    
    // 纹理
    if (frame.diskTexture || frame.wc3Texture) {
      fdf += this.getIndent() + 'Texture {\n';
      this.indentLevel++;
      
      const texturePath = frame.diskTexture || frame.wc3Texture;
      fdf += this.getIndent() + `File "${this.escapeString(texturePath)}"\n`;
      
      this.indentLevel--;
      fdf += this.getIndent() + '}\n';
    }
    
    // 背景纹理
    if (frame.backDiskTexture || frame.backWc3Texture) {
      fdf += this.getIndent() + `BackdropBackground "${this.escapeString(frame.backDiskTexture || frame.backWc3Texture || '')}"\n`;
    }
    
    this.indentLevel--;
    fdf += this.getIndent() + '}\n';
    
    return fdf;
  }
  
  /**
   * 获取当前缩进
   */
  private getIndent(): string {
    return this.options.indent.repeat(this.indentLevel);
  }
  
  /**
   * 转换像素值为相对值（0-1 范围）
   */
  private toRelative(pixels: number, base: number): string {
    const relative = pixels / base;
    return relative.toFixed(6);
  }
  
  /**
   * 映射 FrameType 枚举到 FDF 类型名称
   */
  private mapFrameType(type: number): string {
    const FrameType: Record<number, string> = {
      0: 'FRAME',          // ORIGIN
      1: 'BACKDROP',       // BACKDROP
      2: 'BUTTON',         // BUTTON
      3: 'BUTTON',         // BROWSER_BUTTON
      4: 'BUTTON',         // SCRIPT_DIALOG_BUTTON
      5: 'CHECKBOX',       // CHECKLIST_BOX
      6: 'BACKDROP',       // ESC_MENU_BACKDROP
      7: 'BACKDROP',       // OPTIONS_POPUP_MENU_BACKDROP_TEMPLATE
      8: 'BUTTON',         // QUEST_BUTTON_BASE_TEMPLATE
      9: 'BACKDROP',       // QUEST_BUTTON_DISABLED_BACKDROP_TEMPLATE
      10: 'BACKDROP',      // QUEST_BUTTON_PUSHED_BACKDROP_TEMPLATE
      11: 'CHECKBOX',      // CHECKBOX
      12: 'BUTTON',        // INVIS_BUTTON
      13: 'TEXT',          // TEXT_FRAME
      14: 'BACKDROP',      // HORIZONTAL_BAR
      15: 'BACKDROP',      // HOR_BAR_BACKGROUND
      16: 'TEXT',          // HOR_BAR_TEXT
      17: 'TEXT',          // HOR_BAR_BACKGROUND_TEXT
      18: 'TEXT',          // TEXTAREA
      19: 'EDITBOX',       // EDITBOX
      20: 'SLIDER',        // SLIDER
    };
    
    return FrameType[type] || 'BACKDROP';
  }
  
  /**
   * 映射 FramePoint 枚举到名称
   */
  private mapFramePointToName(point: number): string {
    const points = [
      'TOPLEFT',
      'TOP',
      'TOPRIGHT',
      'LEFT',
      'CENTER',
      'RIGHT',
      'BOTTOMLEFT',
      'BOTTOM',
      'BOTTOMRIGHT',
    ];
    
    return points[point] || 'TOPLEFT';
  }
  
  /**
   * 映射水平对齐
   */
  private mapHorizontalAlign(align: string): string {
    switch (align) {
      case 'left': return 'JUSTIFYLEFT';
      case 'center': return 'JUSTIFYCENTER';
      case 'right': return 'JUSTIFYRIGHT';
      default: return 'JUSTIFYCENTER';
    }
  }
  
  /**
   * 映射垂直对齐
   */
  private mapVerticalAlign(align: string): string {
    switch (align) {
      case 'start': return 'JUSTIFYTOP';
      case 'center': return 'JUSTIFYMIDDLE';
      case 'flex-end': return 'JUSTIFYBOTTOM';
      default: return 'JUSTIFYMIDDLE';
    }
  }
  
  /**
   * 将 Hex 颜色转换为 RGBA
   */
  private hexToRgba(hex: string): { r: number, g: number, b: number, a: number } {
    const cleanHex = hex.replace('#', '');
    
    let r = 0, g = 0, b = 0, a = 1;
    
    if (cleanHex.length === 6) {
      r = parseInt(cleanHex.substring(0, 2), 16) / 255;
      g = parseInt(cleanHex.substring(2, 4), 16) / 255;
      b = parseInt(cleanHex.substring(4, 6), 16) / 255;
    } else if (cleanHex.length === 8) {
      r = parseInt(cleanHex.substring(0, 2), 16) / 255;
      g = parseInt(cleanHex.substring(2, 4), 16) / 255;
      b = parseInt(cleanHex.substring(4, 6), 16) / 255;
      a = parseInt(cleanHex.substring(6, 8), 16) / 255;
    }
    
    return { r, g, b, a };
  }
  
  /**
   * 转义字符串
   */
  private escapeString(str: string): string {
    return str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\t/g, '\\t')
      .replace(/\r/g, '\\r');
  }
}
