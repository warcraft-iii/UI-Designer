/**
 * FDF 导出器
 * 
 * 将 FrameData 转换为 FDF 格式文本
 */

import { FrameData } from '../types';

/**
 * 导出选项
 */
export interface ExportOptions {
  /** 缩进字符串 */
  indent?: string;
  /** 是否包含注释 */
  includeComments?: boolean;
  /** 基础画布宽度（用于转换相对坐标） */
  baseWidth?: number;
  /** 基础画布高度（用于转换相对坐标） */
  baseHeight?: number;
}

/**
 * 增强导出选项
 */
export interface EnhancedExportOptions extends ExportOptions {
  /** 是否启用无损导出（保留所有元数据） */
  lossless?: boolean;
  /** 是否合并原始属性和运行时属性 */
  mergeRawProperties?: boolean;
  /** 是否智能处理 INHERITS（只导出覆盖的属性） */
  smartInheritance?: boolean;
  /** 是否导出嵌套的 Frame 结构 */
  exportNestedFrames?: boolean;
  /** 已导出的模板注册表（用于避免重复导出） */
  templateRegistry?: Map<string, FrameData>;
}

/**
 * FDF 导出器
 */
export class FDFExporter {
  private options: Required<ExportOptions>;
  private indentLevel: number = 0;
  
  constructor(options: ExportOptions = {}) {
    this.options = {
      indent: options.indent ?? '\t',
      includeComments: options.includeComments ?? true,
      baseWidth: options.baseWidth ?? 800,
      baseHeight: options.baseHeight ?? 600,
    };
  }
  
  /**
   * 导出 Frame 数组为 FDF 文本
   */
  public export(frames: FrameData[]): string {
    let fdf = '';
    
    if (this.options.includeComments) {
      fdf += '// Generated by WC3 UI Designer\n';
      fdf += `// ${new Date().toISOString()}\n`;
      fdf += '\n';
    }
    
    for (const frame of frames) {
      fdf += this.exportFrame(frame);
      fdf += '\n';
    }
    
    return fdf;
  }
  
  /**
   * 导出单个 Frame
   */
  private exportFrame(frame: FrameData): string {
    let fdf = '';
    
    const frameType = this.mapFrameType(frame.type);
    const frameName = frame.name || `Frame_${frame.id}`;
    
    // Frame 定义（带可选的 INHERITS）
    const inherits = frame.fdfMetadata?.inherits;
    if (inherits) {
      fdf += this.getIndent() + `Frame "${frameType}" "${frameName}" INHERITS "${inherits}" {\n`;
    } else {
      fdf += this.getIndent() + `Frame "${frameType}" "${frameName}" {\n`;
    }
    this.indentLevel++;
    
    // 尺寸
    if (frame.width) {
      fdf += this.getIndent() + `Width ${this.toRelative(frame.width, this.options.baseWidth)}\n`;
    }
    if (frame.height) {
      fdf += this.getIndent() + `Height ${this.toRelative(frame.height, this.options.baseHeight)}\n`;
    }
    
    // 锚点
    if (frame.anchors && frame.anchors.length > 0) {
      for (const anchor of frame.anchors) {
        const pointName = this.mapFramePointToName(anchor.point);
        
        if (anchor.relativeTo) {
          // SetPoint 相对定位
          const relativePointName = this.mapFramePointToName(anchor.relativePoint || 0);
          const offsetX = this.toRelative(anchor.x, this.options.baseWidth);
          const offsetY = this.toRelative(anchor.y, this.options.baseHeight);
          fdf += this.getIndent() + `SetPoint ${pointName}, "${anchor.relativeTo}", ${relativePointName}, ${offsetX}, ${offsetY}\n`;
        } else {
          // Anchor 绝对定位
          const x = this.toRelative(anchor.x, this.options.baseWidth);
          const y = this.toRelative(anchor.y, this.options.baseHeight);
          fdf += this.getIndent() + `Anchor ${pointName}, ${x}, ${y}\n`;
        }
      }
    }
    
    // 文本
    if (frame.text) {
      fdf += this.getIndent() + `Text "${this.escapeString(frame.text)}"\n`;
    }
    
    if (frame.textColor) {
      const rgba = this.hexToRgba(frame.textColor);
      fdf += this.getIndent() + `FontColor ${rgba.r} ${rgba.g} ${rgba.b} ${rgba.a}\n`;
    }
    
    if (frame.horAlign) {
      const justification = this.mapHorizontalAlign(frame.horAlign);
      fdf += this.getIndent() + `FontJustificationH ${justification}\n`;
    }
    
    if (frame.verAlign) {
      const justification = this.mapVerticalAlign(frame.verAlign);
      fdf += this.getIndent() + `FontJustificationV ${justification}\n`;
    }
    
    // 纹理
    if (frame.diskTexture || frame.wc3Texture) {
      fdf += this.getIndent() + 'Texture {\n';
      this.indentLevel++;
      
      const texturePath = frame.diskTexture || frame.wc3Texture || '';
      fdf += this.getIndent() + `File "${this.escapeString(texturePath)}"\n`;
      
      this.indentLevel--;
      fdf += this.getIndent() + '}\n';
    }
    
    // 背景纹理
    if (frame.backDiskTexture || frame.backWc3Texture) {
      fdf += this.getIndent() + `BackdropBackground "${this.escapeString(frame.backDiskTexture || frame.backWc3Texture || '')}"\n`;
    }
    
    this.indentLevel--;
    fdf += this.getIndent() + '}\n';
    
    return fdf;
  }
  
  /**
   * 获取当前缩进
   */
  protected getIndent(): string {
    return this.options.indent.repeat(this.indentLevel);
  }
  
  /**
   * 转换像素值为相对值（0-1 范围）
   */
  protected toRelative(pixels: number, base: number): string {
    const relative = pixels / base;
    return relative.toFixed(6);
  }
  
  /**
   * 映射 FrameType 枚举到 FDF 类型名称
   */
  protected mapFrameType(type: number): string {
    const FrameType: Record<number, string> = {
      // 基础容器
      0: 'FRAME',          // ORIGIN
      1: 'FRAME',          // FRAME
      2: 'BACKDROP',       // BACKDROP
      3: 'SIMPLEFRAME',    // SIMPLEFRAME
      
      // 文本控件
      4: 'TEXT',           // TEXT_FRAME
      5: 'SIMPLEFONTSTRING', // SIMPLEFONTSTRING
      6: 'TEXTAREA',       // TEXTAREA
      
      // 按钮控件
      7: 'BUTTON',         // BUTTON
      8: 'GLUETEXTBUTTON', // GLUETEXTBUTTON
      9: 'GLUEBUTTON',     // GLUEBUTTON
      10: 'SIMPLEBUTTON',  // SIMPLEBUTTON
      11: 'BUTTON',        // BROWSER_BUTTON → BUTTON
      12: 'BUTTON',        // SCRIPT_DIALOG_BUTTON → BUTTON
      13: 'BUTTON',        // INVIS_BUTTON → BUTTON
      
      // 交互控件
      14: 'CHECKBOX',      // CHECKBOX
      15: 'EDITBOX',       // EDITBOX
      16: 'SLIDER',        // SLIDER
      17: 'SCROLLBAR',     // SCROLLBAR
      18: 'LISTBOX',       // LISTBOX
      19: 'MENU',          // MENU
      20: 'POPUPMENU',     // POPUPMENU
      
      // 图形控件
      21: 'SPRITE',        // SPRITE
      22: 'MODEL',         // MODEL
      23: 'HIGHLIGHT',     // HIGHLIGHT
      
      // 状态栏
      24: 'SIMPLESTATUSBAR', // SIMPLESTATUSBAR
      25: 'STATUSBAR',     // STATUSBAR
      
      // 其他控件
      26: 'CONTROL',       // CONTROL
      27: 'DIALOG',        // DIALOG
      28: 'TIMERTEXT',     // TIMERTEXT
      
      // 兼容旧枚举值（映射到对应的新类型）
      100: 'CHECKBOX',     // CHECKLIST_BOX → CHECKBOX
      101: 'BACKDROP',     // ESC_MENU_BACKDROP → BACKDROP
      102: 'BACKDROP',     // OPTIONS_POPUP_MENU_BACKDROP_TEMPLATE → BACKDROP
      103: 'BUTTON',       // QUEST_BUTTON_BASE_TEMPLATE → BUTTON
      104: 'BACKDROP',     // QUEST_BUTTON_DISABLED_BACKDROP_TEMPLATE → BACKDROP
      105: 'BACKDROP',     // QUEST_BUTTON_PUSHED_BACKDROP_TEMPLATE → BACKDROP
      106: 'BACKDROP',     // HORIZONTAL_BAR → BACKDROP
      107: 'BACKDROP',     // HOR_BAR_BACKGROUND → BACKDROP
      108: 'TEXT',         // HOR_BAR_TEXT → TEXT
      109: 'TEXT',         // HOR_BAR_BACKGROUND_TEXT → TEXT
    };
    
    return FrameType[type] || 'FRAME';
  }
  
  /**
   * 映射 FramePoint 枚举到名称
   */
  protected mapFramePointToName(point: number): string {
    const points = [
      'TOPLEFT',
      'TOP',
      'TOPRIGHT',
      'LEFT',
      'CENTER',
      'RIGHT',
      'BOTTOMLEFT',
      'BOTTOM',
      'BOTTOMRIGHT',
    ];
    
    return points[point] || 'TOPLEFT';
  }
  
  /**
   * 映射水平对齐
   */
  protected mapHorizontalAlign(align: string): string {
    switch (align) {
      case 'left': return 'JUSTIFYLEFT';
      case 'center': return 'JUSTIFYCENTER';
      case 'right': return 'JUSTIFYRIGHT';
      default: return 'JUSTIFYCENTER';
    }
  }
  
  /**
   * 映射垂直对齐
   */
  protected mapVerticalAlign(align: string): string {
    switch (align) {
      case 'start': return 'JUSTIFYTOP';
      case 'center': return 'JUSTIFYMIDDLE';
      case 'flex-end': return 'JUSTIFYBOTTOM';
      default: return 'JUSTIFYMIDDLE';
    }
  }
  
  /**
   * 将 Hex 颜色转换为 RGBA
   */
  protected hexToRgba(hex: string): { r: number, g: number, b: number, a: number } {
    const cleanHex = hex.replace('#', '');
    
    let r = 0, g = 0, b = 0, a = 1;
    
    if (cleanHex.length === 6) {
      r = parseInt(cleanHex.substring(0, 2), 16) / 255;
      g = parseInt(cleanHex.substring(2, 4), 16) / 255;
      b = parseInt(cleanHex.substring(4, 6), 16) / 255;
    } else if (cleanHex.length === 8) {
      r = parseInt(cleanHex.substring(0, 2), 16) / 255;
      g = parseInt(cleanHex.substring(2, 4), 16) / 255;
      b = parseInt(cleanHex.substring(4, 6), 16) / 255;
      a = parseInt(cleanHex.substring(6, 8), 16) / 255;
    }
    
    return { r, g, b, a };
  }
  
  /**
   * 转义字符串（类型安全）
   */
  protected escapeString(value: unknown): string {
    // 处理 null/undefined
    if (value === null || value === undefined) {
      return '';
    }
    
    // 处理数组（取第一个元素或连接）
    if (Array.isArray(value)) {
      if (value.length === 0) return '';
      // 如果数组只有一个元素，使用该元素
      if (value.length === 1) {
        return this.escapeString(value[0]);
      }
      // 多个元素，用空格连接
      return value.map(v => String(v)).join(' ');
    }
    
    // 转换为字符串
    const str = String(value);
    
    return str
      .replace(/\\/g, '\\\\')
      .replace(/"/g, '\\"')
      .replace(/\n/g, '\\n')
      .replace(/\t/g, '\\t')
      .replace(/\r/g, '\\r');
  }
}

/**
 * 增强版 FDF 导出器
 * 
 * 支持无损导出、元数据还原、INHERITS 优化等高级功能
 */
export class FDFExporterEnhanced extends FDFExporter {
  private enhancedOptions: Required<EnhancedExportOptions>;
  private frameMap: Map<string, FrameData> = new Map();
  
  constructor(options: EnhancedExportOptions = {}) {
    super(options);
    this.enhancedOptions = {
      ...options,
      indent: options.indent ?? '\t',
      includeComments: options.includeComments ?? true,
      baseWidth: options.baseWidth ?? 800,
      baseHeight: options.baseHeight ?? 600,
      lossless: options.lossless ?? true,
      mergeRawProperties: options.mergeRawProperties ?? true,
      smartInheritance: options.smartInheritance ?? true,
      exportNestedFrames: options.exportNestedFrames ?? true,
      templateRegistry: options.templateRegistry ?? new Map(),
    };
  }
  
  /**
   * 增强版导出
   */
  public exportEnhanced(frames: FrameData[]): string {
    // 构建 Frame ID 映射
    this.buildFrameMap(frames);
    
    let fdf = '';
    
    if (this.enhancedOptions.includeComments) {
      fdf += '// Generated by WC3 UI Designer (Enhanced Export)\n';
      fdf += `// ${new Date().toISOString()}\n`;
      fdf += '// Lossless export with metadata preservation\n';
      fdf += '\n';
    }
    
    // 导出顶层 Frame（没有父级的 Frame）
    const topLevelFrames = frames.filter(f => !f.parentId);
    
    for (const frame of topLevelFrames) {
      fdf += this.exportFrameEnhanced(frame);
      fdf += '\n';
    }
    
    return fdf;
  }
  
  /**
   * 构建 Frame ID 映射
   */
  private buildFrameMap(frames: FrameData[]): void {
    this.frameMap.clear();
    for (const frame of frames) {
      this.frameMap.set(frame.id, frame);
    }
  }
  
  /**
   * 增强版 Frame 导出
   */
  private exportFrameEnhanced(frame: FrameData, indentLevel: number = 0): string {
    let fdf = '';
    const indent = this.enhancedOptions.indent.repeat(indentLevel);
    
    const frameType = this.mapFrameType(frame.type);
    const frameName = frame.name || `Frame_${frame.id}`;
    
    // 添加注释（如果有）
    if (this.enhancedOptions.lossless && frame.fdfMetadata?.comment) {
      fdf += `${indent}// ${frame.fdfMetadata.comment}\n`;
    }
    
    // Frame 定义（带可选的 INHERITS）
    const inherits = frame.fdfMetadata?.inherits;
    if (inherits) {
      fdf += `${indent}Frame "${frameType}" "${frameName}" INHERITS "${inherits}" {\n`;
    } else {
      fdf += `${indent}Frame "${frameType}" "${frameName}" {\n`;
    }
    
    // 导出属性
    fdf += this.exportPropertiesEnhanced(frame, indentLevel + 1);
    
    // 导出嵌套的子 Frame
    if (this.enhancedOptions.exportNestedFrames && frame.children.length > 0) {
      for (const childId of frame.children) {
        const childFrame = this.frameMap.get(childId);
        if (childFrame) {
          fdf += '\n';
          fdf += this.exportFrameEnhanced(childFrame, indentLevel + 1);
        }
      }
    }
    
    fdf += `${indent}}\n`;
    
    return fdf;
  }
  
  /**
   * 导出属性（增强版）
   */
  private exportPropertiesEnhanced(frame: FrameData, indentLevel: number): string {
    let fdf = '';
    const indent = this.enhancedOptions.indent.repeat(indentLevel);
    
    // 1. 优先导出原始属性（如果启用了 lossless 模式）
    if (this.enhancedOptions.lossless && this.enhancedOptions.mergeRawProperties && frame.fdfMetadata?.rawProperties) {
      const rawProps = frame.fdfMetadata.rawProperties;
      const exportedProps = new Set<string>();
      
      // 导出原始属性
      for (const [key, value] of Object.entries(rawProps)) {
        fdf += this.exportRawProperty(key, value, indent);
        exportedProps.add(key.toLowerCase());
      }
      
      // 2. 导出运行时修改的属性（不在原始属性中的）
      fdf += this.exportRuntimeProperties(frame, indent, exportedProps);
    } else {
      // 标准导出模式：只导出运行时属性
      fdf += this.exportRuntimeProperties(frame, indent, new Set());
    }
    
    return fdf;
  }
  
  /**
   * 导出原始属性
   */
  private exportRawProperty(key: string, value: any, indent: string): string {
    let fdf = '';
    
    // 特殊处理：数组属性
    if (Array.isArray(value)) {
      fdf += `${indent}${key} ${value.join(', ')}\n`;
      return fdf;
    }
    
    // 特殊处理：对象属性（如 Texture、ControlStyle 等）
    if (typeof value === 'object' && value !== null) {
      fdf += `${indent}${key} {\n`;
      for (const [subKey, subValue] of Object.entries(value)) {
        fdf += this.exportRawProperty(subKey, subValue, indent + this.enhancedOptions.indent);
      }
      fdf += `${indent}}\n`;
      return fdf;
    }
    
    // 字符串属性
    if (typeof value === 'string') {
      fdf += `${indent}${key} "${this.escapeString(value)}"\n`;
      return fdf;
    }
    
    // 数值和布尔属性
    fdf += `${indent}${key} ${value}\n`;
    return fdf;
  }
  
  /**
   * 导出运行时属性
   */
  private exportRuntimeProperties(frame: FrameData, indent: string, exportedProps: Set<string>): string {
    let fdf = '';
    
    // Width & Height
    if (!exportedProps.has('width') && frame.width) {
      fdf += `${indent}Width ${this.toRelative(frame.width, this.enhancedOptions.baseWidth)}\n`;
    }
    if (!exportedProps.has('height') && frame.height) {
      fdf += `${indent}Height ${this.toRelative(frame.height, this.enhancedOptions.baseHeight)}\n`;
    }
    
    // 锚点
    if (!exportedProps.has('setpoint') && !exportedProps.has('anchor') && frame.anchors && frame.anchors.length > 0) {
      for (const anchor of frame.anchors) {
        const pointName = this.mapFramePointToName(anchor.point);
        
        if (anchor.relativeTo) {
          const relativePointName = this.mapFramePointToName(anchor.relativePoint || 0);
          const offsetX = this.toRelative(anchor.x, this.enhancedOptions.baseWidth);
          const offsetY = this.toRelative(anchor.y, this.enhancedOptions.baseHeight);
          fdf += `${indent}SetPoint ${pointName}, "${anchor.relativeTo}", ${relativePointName}, ${offsetX}, ${offsetY}\n`;
        } else {
          const x = this.toRelative(anchor.x, this.enhancedOptions.baseWidth);
          const y = this.toRelative(anchor.y, this.enhancedOptions.baseHeight);
          fdf += `${indent}Anchor ${pointName}, ${x}, ${y}\n`;
        }
      }
    }
    
    // 文本属性
    if (!exportedProps.has('text') && frame.text) {
      fdf += `${indent}Text "${this.escapeString(frame.text)}"\n`;
    }
    
    if (!exportedProps.has('fontcolor') && frame.textColor) {
      const rgba = this.hexToRgba(frame.textColor);
      fdf += `${indent}FontColor ${rgba.r} ${rgba.g} ${rgba.b} ${rgba.a}\n`;
    }
    
    if (!exportedProps.has('fontjustificationh') && frame.horAlign) {
      const justification = this.mapHorizontalAlign(frame.horAlign);
      fdf += `${indent}FontJustificationH ${justification}\n`;
    }
    
    if (!exportedProps.has('fontjustificationv') && frame.verAlign) {
      const justification = this.mapVerticalAlign(frame.verAlign);
      fdf += `${indent}FontJustificationV ${justification}\n`;
    }
    
    // 纹理
    if (!exportedProps.has('texture') && (frame.diskTexture || frame.wc3Texture || frame.fdfTexture)) {
      fdf += this.exportTexture(frame, indent);
    }
    
    // 背景纹理
    if (!exportedProps.has('backdropbackground') && (frame.backDiskTexture || frame.backWc3Texture)) {
      fdf += `${indent}BackdropBackground "${this.escapeString(frame.backDiskTexture || frame.backWc3Texture || '')}"\n`;
    }
    
    return fdf;
  }
  
  /**
   * 导出纹理块
   */
  private exportTexture(frame: FrameData, indent: string): string {
    let fdf = '';
    
    // 如果有详细的 fdfTexture 数据，使用它
    if (frame.fdfTexture) {
      fdf += `${indent}Texture {\n`;
      const innerIndent = indent + this.enhancedOptions.indent;
      
      fdf += `${innerIndent}File "${this.escapeString(frame.fdfTexture.file)}"\n`;
      
      if (frame.fdfTexture.texCoord) {
        const [left, right, top, bottom] = frame.fdfTexture.texCoord;
        fdf += `${innerIndent}TexCoord ${left}, ${right}, ${top}, ${bottom}\n`;
      }
      
      if (frame.fdfTexture.alphaMode) {
        fdf += `${innerIndent}AlphaMode "${frame.fdfTexture.alphaMode}"\n`;
      }
      
      if (frame.fdfTexture.decorateFileNames !== undefined) {
        fdf += `${innerIndent}DecorateFileNames ${frame.fdfTexture.decorateFileNames}\n`;
      }
      
      fdf += `${indent}}\n`;
    } else if (frame.diskTexture || frame.wc3Texture) {
      // 简化版纹理导出
      fdf += `${indent}Texture {\n`;
      const innerIndent = indent + this.enhancedOptions.indent;
      const texturePath = frame.diskTexture || frame.wc3Texture || '';
      fdf += `${innerIndent}File "${this.escapeString(texturePath)}"\n`;
      fdf += `${indent}}\n`;
    }
    
    return fdf;
  }
}
